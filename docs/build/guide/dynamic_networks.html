<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dynamic Networks · NetworkDynamic.jl</title><meta name="title" content="Dynamic Networks · NetworkDynamic.jl"/><meta property="og:title" content="Dynamic Networks · NetworkDynamic.jl"/><meta property="twitter:title" content="Dynamic Networks · NetworkDynamic.jl"/><meta name="description" content="Documentation for NetworkDynamic.jl."/><meta property="og:description" content="Documentation for NetworkDynamic.jl."/><meta property="twitter:description" content="Documentation for NetworkDynamic.jl."/><meta property="og:url" content="https://Statistical-network-analysis-with-Julia.github.io/NetworkDynamic.jl/guide/dynamic_networks.html"/><meta property="twitter:url" content="https://Statistical-network-analysis-with-Julia.github.io/NetworkDynamic.jl/guide/dynamic_networks.html"/><link rel="canonical" href="https://Statistical-network-analysis-with-Julia.github.io/NetworkDynamic.jl/guide/dynamic_networks.html"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.svg" alt="NetworkDynamic.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">NetworkDynamic.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><span class="tocitem">User Guide</span><ul><li class="is-active"><a class="tocitem" href="dynamic_networks.html">Dynamic Networks</a><ul class="internal"><li><a class="tocitem" href="#The-DynamicNetwork-Type"><span>The DynamicNetwork Type</span></a></li><li><a class="tocitem" href="#Creating-Dynamic-Networks"><span>Creating Dynamic Networks</span></a></li><li><a class="tocitem" href="#The-Observation-Period"><span>The Observation Period</span></a></li><li><a class="tocitem" href="#Graphs.jl-Interface"><span>Graphs.jl Interface</span></a></li><li><a class="tocitem" href="#Network-Extraction"><span>Network Extraction</span></a></li><li><a class="tocitem" href="#Converting-from-Static-Networks"><span>Converting from Static Networks</span></a></li><li><a class="tocitem" href="#Reconciling-Activity"><span>Reconciling Activity</span></a></li><li><a class="tocitem" href="#Building-Dynamic-Networks-from-Data"><span>Building Dynamic Networks from Data</span></a></li><li><a class="tocitem" href="#Memory-and-Performance"><span>Memory and Performance</span></a></li><li><a class="tocitem" href="#Printing-and-Inspection"><span>Printing and Inspection</span></a></li></ul></li><li><a class="tocitem" href="spells.html">Spells and Activity</a></li><li><a class="tocitem" href="queries.html">Time Queries</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/types.html">Types</a></li><li><a class="tocitem" href="../api/functions.html">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href="dynamic_networks.html">Dynamic Networks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="dynamic_networks.html">Dynamic Networks</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Statistical-network-analysis-with-Julia/NetworkDynamic.jl/blob/main/docs/src/guide/dynamic_networks.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Dynamic-Networks"><a class="docs-heading-anchor" href="#Dynamic-Networks">Dynamic Networks</a><a id="Dynamic-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-Networks" title="Permalink"></a></h1><p>This guide covers the <code>DynamicNetwork</code> type in detail, including its structure, construction, and relationship to static networks.</p><h2 id="The-DynamicNetwork-Type"><a class="docs-heading-anchor" href="#The-DynamicNetwork-Type">The DynamicNetwork Type</a><a id="The-DynamicNetwork-Type-1"></a><a class="docs-heading-anchor-permalink" href="#The-DynamicNetwork-Type" title="Permalink"></a></h2><p>A <code>DynamicNetwork{T, Time}</code> wraps a static <code>Network{T}</code> with temporal information. It has two type parameters:</p><ul><li><code>T</code>: The vertex ID type (typically <code>Int</code>)</li><li><code>Time</code>: The timestamp type (<code>Float64</code>, <code>DateTime</code>, <code>Date</code>, or any ordered type)</li></ul><h3 id="Internal-Structure"><a class="docs-heading-anchor" href="#Internal-Structure">Internal Structure</a><a id="Internal-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Structure" title="Permalink"></a></h3><pre><code class="language-julia hljs">mutable struct DynamicNetwork{T&lt;:Integer, Time}
    network::Network{T}                                  # Base static network
    vertex_spells::Dict{T, Vector{Spell{Time}}}           # Vertex activity
    edge_spells::Dict{Tuple{T,T}, Vector{Spell{Time}}}    # Edge activity
    vertex_tea::Dict{Tuple{T,Symbol}, TimeVaryingAttribute}  # Vertex TEAs
    edge_tea::Dict{Tuple{Tuple{T,T},Symbol}, TimeVaryingAttribute}  # Edge TEAs
    observation_period::Tuple{Time, Time}                 # Observation window
    net_obs_period::Spell{Time}                           # Same as Spell
end</code></pre><p>The underlying <code>network</code> field stores the <strong>maximum</strong> set of vertices and edges – those that are ever active. Activity spells then restrict which elements exist at any given time.</p><h2 id="Creating-Dynamic-Networks"><a class="docs-heading-anchor" href="#Creating-Dynamic-Networks">Creating Dynamic Networks</a><a id="Creating-Dynamic-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Dynamic-Networks" title="Permalink"></a></h2><h3 id="Basic-Construction"><a class="docs-heading-anchor" href="#Basic-Construction">Basic Construction</a><a id="Basic-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Construction" title="Permalink"></a></h3><pre><code class="language-julia hljs">using NetworkDynamic

# Specify type parameters explicitly
dnet = DynamicNetwork{Int, Float64}(10;
    observation_start=0.0,
    observation_end=100.0
)

# Use defaults (Int vertices, Float64 time)
dnet = DynamicNetwork(10;
    observation_start=0.0,
    observation_end=100.0
)

# Empty network (0 vertices)
dnet = DynamicNetwork(;
    observation_start=0.0,
    observation_end=50.0
)</code></pre><h3 id="Directed-vs.-Undirected"><a class="docs-heading-anchor" href="#Directed-vs.-Undirected">Directed vs. Undirected</a><a id="Directed-vs.-Undirected-1"></a><a class="docs-heading-anchor-permalink" href="#Directed-vs.-Undirected" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Directed network (default)
dnet_dir = DynamicNetwork(5;
    observation_start=0.0,
    observation_end=10.0,
    directed=true
)

# Undirected network
dnet_undir = DynamicNetwork(5;
    observation_start=0.0,
    observation_end=10.0,
    directed=false
)</code></pre><p>For undirected networks, edge keys are normalized so that <code>(min(i,j), max(i,j))</code> is always used. This means <code>activate!(dnet, 0.0, 5.0; edge=(3, 1))</code> and <code>activate!(dnet, 0.0, 5.0; edge=(1, 3))</code> refer to the same edge.</p><h3 id="With-DateTime-Timestamps"><a class="docs-heading-anchor" href="#With-DateTime-Timestamps">With DateTime Timestamps</a><a id="With-DateTime-Timestamps-1"></a><a class="docs-heading-anchor-permalink" href="#With-DateTime-Timestamps" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Dates

dnet = DynamicNetwork{Int, DateTime}(20;
    observation_start=DateTime(2024, 1, 1),
    observation_end=DateTime(2024, 12, 31)
)

# Add activity spells with DateTime
activate!(dnet, DateTime(2024, 1, 1), DateTime(2024, 6, 30); vertex=1)
activate!(dnet, DateTime(2024, 3, 1), DateTime(2024, 9, 30); edge=(1, 2))</code></pre><h3 id="With-Date-Timestamps"><a class="docs-heading-anchor" href="#With-Date-Timestamps">With Date Timestamps</a><a id="With-Date-Timestamps-1"></a><a class="docs-heading-anchor-permalink" href="#With-Date-Timestamps" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Dates

dnet = DynamicNetwork{Int, Date}(10;
    observation_start=Date(2024, 1, 1),
    observation_end=Date(2024, 12, 31)
)

activate!(dnet, Date(2024, 1, 1), Date(2024, 6, 30); vertex=1)</code></pre><h2 id="The-Observation-Period"><a class="docs-heading-anchor" href="#The-Observation-Period">The Observation Period</a><a id="The-Observation-Period-1"></a><a class="docs-heading-anchor-permalink" href="#The-Observation-Period" title="Permalink"></a></h2><p>The observation period defines the overall time window for the network. It does not constrain spell activity (spells can extend beyond the observation period), but it provides context for analysis.</p><h3 id="Getting-and-Setting"><a class="docs-heading-anchor" href="#Getting-and-Setting">Getting and Setting</a><a id="Getting-and-Setting-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-and-Setting" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Get current observation period
period = get_observation_period(dnet)
println(&quot;Start: $(period[1]), End: $(period[2])&quot;)

# Update observation period
set_observation_period!(dnet, 0.0, 200.0)</code></pre><h3 id="Timing-Information"><a class="docs-heading-anchor" href="#Timing-Information">Timing Information</a><a id="Timing-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Timing-Information" title="Permalink"></a></h3><p>Get comprehensive timing statistics:</p><pre><code class="language-julia hljs">info = get_timing_info(dnet)

println(&quot;Observation period: &quot;, info.observation_period)
println(&quot;Earliest data: &quot;, info.data_start)
println(&quot;Latest data: &quot;, info.data_end)
println(&quot;Vertex spells: &quot;, info.n_vertex_spells)
println(&quot;Edge spells: &quot;, info.n_edge_spells)</code></pre><p>The <code>data_start</code> and <code>data_end</code> fields reflect the actual range of spell data, which may differ from the observation period.</p><h2 id="Graphs.jl-Interface"><a class="docs-heading-anchor" href="#Graphs.jl-Interface">Graphs.jl Interface</a><a id="Graphs.jl-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs.jl-Interface" title="Permalink"></a></h2><p><code>DynamicNetwork</code> forwards key Graphs.jl queries to its underlying <code>Network</code>:</p><pre><code class="language-julia hljs">using Graphs

nv(dnet)            # Total number of vertices (maximum set)
ne(dnet)            # Total number of edges (maximum set)
vertices(dnet)      # Iterate over all vertex IDs
is_directed(dnet)   # Check if directed</code></pre><p>These operate on the <strong>maximum</strong> set of vertices and edges, not the active set at any particular time. To get the active set, use <code>network_extract</code>.</p><h2 id="Network-Extraction"><a class="docs-heading-anchor" href="#Network-Extraction">Network Extraction</a><a id="Network-Extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Extraction" title="Permalink"></a></h2><p>Network extraction produces a static <code>Network{T}</code> from a <code>DynamicNetwork</code> at a given time or during an interval.</p><h3 id="Point-Extraction"><a class="docs-heading-anchor" href="#Point-Extraction">Point Extraction</a><a id="Point-Extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Extraction" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Static network at time 25.0
snapshot = network_extract(dnet, 25.0)

# Use with any Graphs.jl function
println(&quot;Active vertices: &quot;, nv(snapshot))
println(&quot;Active edges: &quot;, ne(snapshot))
println(&quot;Density: &quot;, ne(snapshot) / (nv(snapshot) * (nv(snapshot) - 1)))</code></pre><p>Vertices and edges are re-indexed in the extracted network. If vertices 2, 4, and 5 are active, they become vertices 1, 2, and 3 in the snapshot.</p><h3 id="Interval-Extraction"><a class="docs-heading-anchor" href="#Interval-Extraction">Interval Extraction</a><a id="Interval-Extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Interval-Extraction" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Any activity during [10, 30] -- union of active elements
snapshot_any = network_extract(dnet, 10.0, 30.0; rule=:any)

# Active throughout [10, 30] -- intersection
snapshot_all = network_extract(dnet, 10.0, 30.0; rule=:all)</code></pre><p>The <code>:any</code> rule includes any element active at any point during the interval. The <code>:all</code> rule requires continuous activity throughout.</p><h3 id="Slice-and-Collapse"><a class="docs-heading-anchor" href="#Slice-and-Collapse">Slice and Collapse</a><a id="Slice-and-Collapse-1"></a><a class="docs-heading-anchor-permalink" href="#Slice-and-Collapse" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Extract a sequence of snapshots
times = collect(0.0:5.0:50.0)
snapshots = network_slice(dnet, times)

# Collapse to static (union of all ever-active elements)
static = network_collapse(dnet)</code></pre><h2 id="Converting-from-Static-Networks"><a class="docs-heading-anchor" href="#Converting-from-Static-Networks">Converting from Static Networks</a><a id="Converting-from-Static-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-from-Static-Networks" title="Permalink"></a></h2><p>Convert an existing static <code>Network</code> to a <code>DynamicNetwork</code>:</p><pre><code class="language-julia hljs">using Network

# Create static network
net = Network{Int}(; n=5, directed=true)
add_edge!(net, 1, 2)
add_edge!(net, 2, 3)
add_edge!(net, 3, 1)

# Convert: all elements active during [0, 100]
dnet = as_dynamic_network(net; onset=0.0, terminus=100.0)

# Verify
println(&quot;Vertex spells for v=1: &quot;, get_spells(dnet; vertex=1))
println(&quot;Edge spells for (1,2): &quot;, get_spells(dnet; edge=(1, 2)))</code></pre><h2 id="Reconciling-Activity"><a class="docs-heading-anchor" href="#Reconciling-Activity">Reconciling Activity</a><a id="Reconciling-Activity-1"></a><a class="docs-heading-anchor-permalink" href="#Reconciling-Activity" title="Permalink"></a></h2><p>Edge activity should be consistent with vertex activity. An edge <code>(i, j)</code> can only be active when both vertices <code>i</code> and <code>j</code> are active. After modifying vertex spells, call <code>reconcile_activity!</code> to enforce this constraint:</p><pre><code class="language-julia hljs"># Initial setup
activate!(dnet, 0.0, 50.0; vertex=1)
activate!(dnet, 0.0, 100.0; vertex=2)
activate!(dnet, 0.0, 80.0; edge=(1, 2))

# Vertex 1 is only active until t=50, but edge (1,2) is marked active until t=80
# reconcile_activity! will trim the edge spell to [0, 50]
reconcile_activity!(dnet)

# After reconciliation, edge (1,2) is only active during [0, 50]
spells = get_spells(dnet; edge=(1, 2))
println(spells)  # Spell(0.0, 50.0)</code></pre><h3 id="How-Reconciliation-Works"><a class="docs-heading-anchor" href="#How-Reconciliation-Works">How Reconciliation Works</a><a id="How-Reconciliation-Works-1"></a><a class="docs-heading-anchor-permalink" href="#How-Reconciliation-Works" title="Permalink"></a></h3><p>For each edge spell, the function computes the intersection with the vertex activity of both endpoints. If neither endpoint has vertex spells defined, the edge is assumed to be valid (vertices are always active).</p><pre><code class="language-julia hljs"># Example: Edge intersected with vertex activity
# Vertex 1: active [0, 30] and [50, 80]
# Vertex 2: active [10, 90]
# Edge (1,2): active [0, 100]
# After reconciliation: edge active [10, 30] and [50, 80]
#   (intersection of edge spell with both vertex spells)</code></pre><h2 id="Building-Dynamic-Networks-from-Data"><a class="docs-heading-anchor" href="#Building-Dynamic-Networks-from-Data">Building Dynamic Networks from Data</a><a id="Building-Dynamic-Networks-from-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Dynamic-Networks-from-Data" title="Permalink"></a></h2><h3 id="From-a-List-of-Edges-with-Times"><a class="docs-heading-anchor" href="#From-a-List-of-Edges-with-Times">From a List of Edges with Times</a><a id="From-a-List-of-Edges-with-Times-1"></a><a class="docs-heading-anchor-permalink" href="#From-a-List-of-Edges-with-Times" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Edge data: (source, target, onset, terminus)
edge_data = [
    (1, 2, 0.0, 10.0),
    (2, 3, 5.0, 15.0),
    (1, 3, 10.0, 20.0),
    (3, 4, 15.0, 25.0),
]

# Create network
n_vertices = 4
dnet = DynamicNetwork(n_vertices;
    observation_start=0.0,
    observation_end=30.0
)

# Activate all vertices for the full period
activate_vertices!(dnet, collect(1:n_vertices), 0.0, 30.0)

# Add edge spells
for (i, j, onset, terminus) in edge_data
    activate!(dnet, onset, terminus; edge=(i, j))
end</code></pre><h3 id="From-Panel-Data-(Discrete-Time)"><a class="docs-heading-anchor" href="#From-Panel-Data-(Discrete-Time)">From Panel Data (Discrete Time)</a><a id="From-Panel-Data-(Discrete-Time)-1"></a><a class="docs-heading-anchor-permalink" href="#From-Panel-Data-(Discrete-Time)" title="Permalink"></a></h3><p>When you have a sequence of static networks at fixed time points:</p><pre><code class="language-julia hljs">using Network

# Suppose you have networks at times 1, 2, 3
nets = [net_t1, net_t2, net_t3]
n = nv(nets[1])

dnet = DynamicNetwork(n;
    observation_start=1.0,
    observation_end=4.0  # one past last time point
)

# Activate all vertices for the full period
activate_vertices!(dnet, collect(1:n), 1.0, 4.0)

# Add edge spells from each time step
for (t, net) in enumerate(nets)
    for e in edges(net)
        activate!(dnet, Float64(t), Float64(t + 1); edge=(src(e), dst(e)))
    end
end

# Merge adjacent spells for edges that persist across time points
for ((i, j), _) in dnet.edge_spells
    merge_spells!(dnet; edge=(i, j))
end</code></pre><h2 id="Memory-and-Performance"><a class="docs-heading-anchor" href="#Memory-and-Performance">Memory and Performance</a><a id="Memory-and-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-and-Performance" title="Permalink"></a></h2><h3 id="Storage-Considerations"><a class="docs-heading-anchor" href="#Storage-Considerations">Storage Considerations</a><a id="Storage-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Storage-Considerations" title="Permalink"></a></h3><ul><li>Each spell object stores onset, terminus, and two boolean flags</li><li>Vertex spells are stored in a <code>Dict{T, Vector{Spell{Time}}}</code></li><li>Edge spells are stored in a <code>Dict{Tuple{T,T}, Vector{Spell{Time}}}</code></li><li>Time-varying attributes add additional storage per attribute per spell</li></ul><h3 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h3><ol><li><strong>Merge spells</strong>: Call <code>merge_spells!</code> to reduce the number of spell objects when overlapping spells accumulate</li><li><strong>Extract once</strong>: If you need the same snapshot repeatedly, extract it once and reuse the <code>Network</code> object</li><li><strong>Use appropriate time types</strong>: <code>Float64</code> is faster than <code>DateTime</code> for arithmetic</li><li><strong>Pre-allocate vertices</strong>: Specify the vertex count at construction time rather than growing incrementally</li></ol><h2 id="Printing-and-Inspection"><a class="docs-heading-anchor" href="#Printing-and-Inspection">Printing and Inspection</a><a id="Printing-and-Inspection-1"></a><a class="docs-heading-anchor-permalink" href="#Printing-and-Inspection" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Basic info
println(&quot;Vertices: &quot;, nv(dnet))
println(&quot;Edges: &quot;, ne(dnet))
println(&quot;Directed: &quot;, is_directed(dnet))
println(&quot;Observation: &quot;, get_observation_period(dnet))

# Detailed timing
info = get_timing_info(dnet)
println(&quot;Data range: $(info.data_start) to $(info.data_end)&quot;)
println(&quot;Vertex spells: $(info.n_vertex_spells)&quot;)
println(&quot;Edge spells: $(info.n_edge_spells)&quot;)

# Inspect specific elements
for v in 1:nv(dnet)
    spells = when_vertex(dnet, v)
    if !isempty(spells)
        println(&quot;Vertex $v: &quot;, spells)
    end
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started.html">« Getting Started</a><a class="docs-footer-nextpage" href="spells.html">Spells and Activity »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 11 February 2026 21:00">Wednesday 11 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
