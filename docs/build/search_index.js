var documenterSearchIndex = {"docs":
[{"location":"guide/spells.html#Spells-and-Activity","page":"Spells and Activity","title":"Spells and Activity","text":"This guide covers the Spell type and all operations for managing activity spells on vertices and edges in a dynamic network.","category":"section"},{"location":"guide/spells.html#The-Spell-Type","page":"Spells and Activity","title":"The Spell Type","text":"A Spell{Time} represents a time interval during which a network element is active. The interval is half-open: [onset, terminus) – the onset is inclusive and the terminus is exclusive.","category":"section"},{"location":"guide/spells.html#Creating-Spells","page":"Spells and Activity","title":"Creating Spells","text":"using NetworkDynamic\n\n# Basic spell\ns = Spell(0.0, 10.0)\n\n# With censoring information\ns = Spell(0.0, 10.0;\n    onset_censored=true,     # Activity may have started before onset\n    terminus_censored=false   # Terminus is known\n)","category":"section"},{"location":"guide/spells.html#Censoring","page":"Spells and Activity","title":"Censoring","text":"Censoring indicates that a spell boundary may not represent the true start or end of activity:\n\nFlag Meaning\nonset_censored=true Activity may have started before the observed onset\nterminus_censored=true Activity may continue beyond the observed terminus\nBoth false (default) Both boundaries are observed precisely\n\nCensoring is metadata – it does not change how spells are processed in queries or extraction. It is useful for recording data quality information.\n\n# Left-censored: we started observing at t=0, but the tie may predate observation\ns = Spell(0.0, 50.0; onset_censored=true)\n\n# Right-censored: observation ended at t=100, but the tie may persist\ns = Spell(30.0, 100.0; terminus_censored=true)\n\n# Interval-censored: both boundaries are uncertain\ns = Spell(0.0, 100.0; onset_censored=true, terminus_censored=true)","category":"section"},{"location":"guide/spells.html#Spell-Properties","page":"Spells and Activity","title":"Spell Properties","text":"s = Spell(5.0, 15.0)\n\ns.onset            # 5.0\ns.terminus         # 15.0\ns.onset_censored   # false\ns.terminus_censored # false","category":"section"},{"location":"guide/spells.html#Spell-Utilities","page":"Spells and Activity","title":"Spell Utilities","text":"# Duration of a spell\nd = spell_duration(s)  # 10.0\n\n# Check if two spells overlap\ns1 = Spell(0.0, 10.0)\ns2 = Spell(5.0, 15.0)\nspell_overlap(s1, s2)  # true\n\ns3 = Spell(10.0, 20.0)\nspell_overlap(s1, s3)  # false (s1 ends exactly when s3 starts)\n\n# Comparison (by onset, then terminus)\ns1 < s2  # true (onset 0 < 5)\ns1 == Spell(0.0, 10.0)  # true","category":"section"},{"location":"guide/spells.html#Spell-Ordering","page":"Spells and Activity","title":"Spell Ordering","text":"Spells are ordered first by onset, then by terminus:\n\nspells = [Spell(5.0, 15.0), Spell(0.0, 10.0), Spell(5.0, 10.0)]\nsort!(spells)\n# Result: [Spell(0.0, 10.0), Spell(5.0, 10.0), Spell(5.0, 15.0)]","category":"section"},{"location":"guide/spells.html#Adding-Spells","page":"Spells and Activity","title":"Adding Spells","text":"","category":"section"},{"location":"guide/spells.html#Using-activate!","page":"Spells and Activity","title":"Using activate!","text":"The most common way to add spells is the activate! function:\n\n# Activate a vertex\nactivate!(dnet, 0.0, 50.0; vertex=1)\n\n# Activate an edge\nactivate!(dnet, 10.0, 30.0; edge=(1, 2))\n\nactivate! is a convenience wrapper that creates a Spell and calls add_spell!.","category":"section"},{"location":"guide/spells.html#Using-add_spell!","page":"Spells and Activity","title":"Using add_spell!","text":"For more control, use add_spell! with a Spell object:\n\n# With censoring\nadd_spell!(dnet, Spell(0.0, 50.0; onset_censored=true); vertex=1)\n\n# Edge spell\nadd_spell!(dnet, Spell(10.0, 30.0); edge=(2, 3))","category":"section"},{"location":"guide/spells.html#Batch-Activation","page":"Spells and Activity","title":"Batch Activation","text":"Activate multiple elements at once:\n\n# Activate vertices 1 through 10 from time 0 to 100\nactivate_vertices!(dnet, collect(1:10), 0.0, 100.0)\n\n# Activate several edges simultaneously\nedges = [(1, 2), (2, 3), (3, 4), (4, 5)]\nactivate_edges!(dnet, edges, 5.0, 50.0)","category":"section"},{"location":"guide/spells.html#Edge-Auto-Creation","page":"Spells and Activity","title":"Edge Auto-Creation","text":"When you add a spell to an edge that does not exist in the underlying static network, the edge is automatically created:\n\ndnet = DynamicNetwork(5; observation_start=0.0, observation_end=10.0)\n# No edges exist yet\n\nactivate!(dnet, 1.0, 5.0; edge=(1, 2))\n# Edge (1,2) is now in the base network and has one spell","category":"section"},{"location":"guide/spells.html#Removing-Spells","page":"Spells and Activity","title":"Removing Spells","text":"Remove a specific spell from a vertex or edge:\n\n# Remove a specific spell\nremove_spell!(dnet, Spell(10.0, 30.0); edge=(1, 2))\n\n# The spell must match exactly (onset and terminus)\ns = Spell(10.0, 30.0)\nremove_spell!(dnet, s; vertex=1)\n\nIf the specified spell does not exist, the function silently does nothing.","category":"section"},{"location":"guide/spells.html#Retrieving-Spells","page":"Spells and Activity","title":"Retrieving Spells","text":"","category":"section"},{"location":"guide/spells.html#Get-All-Spells","page":"Spells and Activity","title":"Get All Spells","text":"# Get spells for a vertex\nspells = get_spells(dnet; vertex=1)\nprintln(\"Vertex 1 has $(length(spells)) spells\")\nfor s in spells\n    println(\"  [$(s.onset), $(s.terminus))\")\nend\n\n# Get spells for an edge\nspells = get_spells(dnet; edge=(1, 2))","category":"section"},{"location":"guide/spells.html#Convenience-Aliases","page":"Spells and Activity","title":"Convenience Aliases","text":"# Equivalent to get_spells(dnet; vertex=v)\nwhen_vertex(dnet, 1)\n\n# Equivalent to get_spells(dnet; edge=(i, j))\nwhen_edge(dnet, 1, 2)","category":"section"},{"location":"guide/spells.html#Activity-Range","page":"Spells and Activity","title":"Activity Range","text":"Get the earliest and latest times for an element:\n\nrange = get_activity_range(dnet; vertex=1)\nif !isnothing(range)\n    println(\"Vertex 1 active from $(range[1]) to $(range[2])\")\nend\n\nrange = get_activity_range(dnet; edge=(1, 2))","category":"section"},{"location":"guide/spells.html#Merging-Spells","page":"Spells and Activity","title":"Merging Spells","text":"When a vertex or edge accumulates overlapping or adjacent spells, merge them into minimal non-overlapping spells:\n\n# Before merging: vertex 1 has overlapping spells\nactivate!(dnet, 0.0, 20.0; vertex=1)\nactivate!(dnet, 15.0, 40.0; vertex=1)\nactivate!(dnet, 35.0, 60.0; vertex=1)\n\n# Spells: [0,20), [15,40), [35,60)\nprintln(get_spells(dnet; vertex=1))  # 3 spells\n\n# Merge overlapping spells\nmerge_spells!(dnet; vertex=1)\n\n# After: [0,60) - one contiguous spell\nprintln(get_spells(dnet; vertex=1))  # 1 spell","category":"section"},{"location":"guide/spells.html#Merge-Rules","page":"Spells and Activity","title":"Merge Rules","text":"Overlapping spells (s1.terminus > s2.onset) are merged\nAdjacent spells (s1.terminus == s2.onset) are merged\nDisjoint spells (gap between them) remain separate\n\n# These merge: [0,10) and [10,20) -> [0,20)\nactivate!(dnet, 0.0, 10.0; vertex=2)\nactivate!(dnet, 10.0, 20.0; vertex=2)\nmerge_spells!(dnet; vertex=2)\n# Result: [0,20)\n\n# These remain separate: [0,10) and [15,25)\nactivate!(dnet, 0.0, 10.0; vertex=3)\nactivate!(dnet, 15.0, 25.0; vertex=3)\nmerge_spells!(dnet; vertex=3)\n# Result: [0,10) and [15,25) -- gap from 10 to 15","category":"section"},{"location":"guide/spells.html#Merging-Edge-Spells","page":"Spells and Activity","title":"Merging Edge Spells","text":"merge_spells!(dnet; edge=(1, 2))","category":"section"},{"location":"guide/spells.html#Spell-Patterns","page":"Spells and Activity","title":"Spell Patterns","text":"","category":"section"},{"location":"guide/spells.html#Continuous-Activity","page":"Spells and Activity","title":"Continuous Activity","text":"A vertex or edge active for the entire observation period:\n\nactivate!(dnet, 0.0, 100.0; vertex=1)","category":"section"},{"location":"guide/spells.html#Intermittent-Activity","page":"Spells and Activity","title":"Intermittent Activity","text":"Active in separate periods with gaps:\n\nactivate!(dnet, 0.0, 20.0; vertex=1)    # First period\nactivate!(dnet, 40.0, 60.0; vertex=1)    # Second period\nactivate!(dnet, 80.0, 100.0; vertex=1)   # Third period","category":"section"},{"location":"guide/spells.html#Progressive-Formation","page":"Spells and Activity","title":"Progressive Formation","text":"Edges form over time:\n\nactivate!(dnet, 0.0, 100.0; edge=(1, 2))   # Exists from start\nactivate!(dnet, 20.0, 100.0; edge=(2, 3))   # Forms at t=20\nactivate!(dnet, 50.0, 100.0; edge=(3, 4))   # Forms at t=50","category":"section"},{"location":"guide/spells.html#Temporal-Ordering","page":"Spells and Activity","title":"Temporal Ordering","text":"Events with short duration, representing interactions:\n\n# Each \"interaction\" lasts a brief period\nactivate!(dnet, 1.0, 1.1; edge=(1, 2))\nactivate!(dnet, 3.5, 3.6; edge=(2, 3))\nactivate!(dnet, 5.0, 5.1; edge=(1, 3))\nactivate!(dnet, 7.2, 7.3; edge=(3, 2))","category":"section"},{"location":"guide/spells.html#Working-with-Different-Time-Types","page":"Spells and Activity","title":"Working with Different Time Types","text":"","category":"section"},{"location":"guide/spells.html#Float64-(Default)","page":"Spells and Activity","title":"Float64 (Default)","text":"dnet = DynamicNetwork(5; observation_start=0.0, observation_end=100.0)\nactivate!(dnet, 0.0, 50.0; vertex=1)\nspell_duration(Spell(0.0, 50.0))  # 50.0","category":"section"},{"location":"guide/spells.html#DateTime","page":"Spells and Activity","title":"DateTime","text":"using Dates\n\ndnet = DynamicNetwork{Int, DateTime}(5;\n    observation_start=DateTime(2024, 1, 1),\n    observation_end=DateTime(2024, 12, 31)\n)\n\nactivate!(dnet, DateTime(2024, 1, 1), DateTime(2024, 6, 30); vertex=1)\n\ns = Spell(DateTime(2024, 1, 1), DateTime(2024, 6, 30))\nd = spell_duration(s)  # Millisecond duration","category":"section"},{"location":"guide/spells.html#Date","page":"Spells and Activity","title":"Date","text":"using Dates\n\ndnet = DynamicNetwork{Int, Date}(5;\n    observation_start=Date(2024, 1, 1),\n    observation_end=Date(2024, 12, 31)\n)\n\nactivate!(dnet, Date(2024, 1, 1), Date(2024, 6, 30); vertex=1)\n\ns = Spell(Date(2024, 1, 1), Date(2024, 6, 30))\nd = spell_duration(s)  # Day duration","category":"section"},{"location":"guide/spells.html#Best-Practices","page":"Spells and Activity","title":"Best Practices","text":"","category":"section"},{"location":"guide/spells.html#Spell-Management","page":"Spells and Activity","title":"Spell Management","text":"Merge periodically: Call merge_spells! after adding many spells to reduce memory usage\nCheck for gaps: Use get_activity_range to verify elements are active when expected\nConsistent time types: All spells in a network must use the same Time type\nOrder matters: Spells are automatically sorted by onset when added","category":"section"},{"location":"guide/spells.html#Data-Quality","page":"Spells and Activity","title":"Data Quality","text":"Mark censoring: Use onset_censored and terminus_censored to document observation boundaries\nValidate constraints: An edge should only be active when both endpoints are active – use reconcile_activity!\nCheck onset <= terminus: The Spell constructor enforces this, throwing ArgumentError otherwise","category":"section"},{"location":"guide/spells.html#Performance","page":"Spells and Activity","title":"Performance","text":"Batch operations: Use activate_vertices! and activate_edges! instead of loops\nMinimize spell count: Merge overlapping spells to reduce storage and query time\nUse get_spells sparingly: For frequent queries, cache the result rather than calling repeatedly","category":"section"},{"location":"api/types.html#Types-API-Reference","page":"Types","title":"Types API Reference","text":"This page documents the core data types in NetworkDynamic.jl.","category":"section"},{"location":"api/types.html#Dynamic-Network","page":"Types","title":"Dynamic Network","text":"","category":"section"},{"location":"api/types.html#DynamicNetwork","page":"Types","title":"DynamicNetwork","text":"","category":"section"},{"location":"api/types.html#Spell-Types","page":"Types","title":"Spell Types","text":"","category":"section"},{"location":"api/types.html#Spell","page":"Types","title":"Spell","text":"","category":"section"},{"location":"api/types.html#TimeVaryingAttribute","page":"Types","title":"TimeVaryingAttribute","text":"","category":"section"},{"location":"api/types.html#Spell-Utilities","page":"Types","title":"Spell Utilities","text":"","category":"section"},{"location":"api/types.html#spell_overlap","page":"Types","title":"spell_overlap","text":"","category":"section"},{"location":"api/types.html#spell_duration","page":"Types","title":"spell_duration","text":"","category":"section"},{"location":"api/types.html#NetworkDynamic.DynamicNetwork","page":"Types","title":"NetworkDynamic.DynamicNetwork","text":"DynamicNetwork{T,Time}\n\nA network with time-varying structure (edges and vertices can appear/disappear).\n\nType Parameters\n\nT: Vertex ID type\nTime: Time type (Float64, DateTime, etc.)\n\nFields\n\nnetwork::Network{T}: Base network structure (maximum set of vertices/edges)\nvertex_spells::Dict{T, Vector{Spell{Time}}}: Activity periods for vertices\nedge_spells::Dict{Tuple{T,T}, Vector{Spell{Time}}}: Activity periods for edges\nvertex_tea::Dict{Tuple{T,Symbol}, TimeVaryingAttribute}: Time-varying vertex attributes\nedge_tea::Dict{Tuple{Tuple{T,T},Symbol}, TimeVaryingAttribute}: Time-varying edge attributes\nobservation_period::Tuple{Time, Time}: Overall observation window\n\n\n\n\n\n","category":"type"},{"location":"api/types.html#NetworkDynamic.Spell","page":"Types","title":"NetworkDynamic.Spell","text":"Spell{T}\n\nRepresents an activity spell (time interval).\n\nFields\n\nonset::T: Start time (inclusive)\nterminus::T: End time (exclusive by default)\nonset_censored::Bool: True if spell may have started earlier\nterminus_censored::Bool: True if spell may continue beyond terminus\n\n\n\n\n\n","category":"type"},{"location":"api/types.html#NetworkDynamic.TimeVaryingAttribute","page":"Types","title":"NetworkDynamic.TimeVaryingAttribute","text":"TimeVaryingAttribute{T, Time, V}\n\nAn attribute that changes over time.\n\n\n\n\n\n","category":"type"},{"location":"api/types.html#NetworkDynamic.spell_overlap","page":"Types","title":"NetworkDynamic.spell_overlap","text":"spell_overlap(s1::Spell, s2::Spell) -> Bool\n\nCheck if two spells overlap.\n\n\n\n\n\n","category":"function"},{"location":"api/types.html#NetworkDynamic.spell_duration","page":"Types","title":"NetworkDynamic.spell_duration","text":"spell_duration(s::Spell) -> Number\n\nGet the duration of a spell.\n\n\n\n\n\n","category":"function"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This tutorial walks through common use cases for NetworkDynamic.jl, from creating dynamic networks to extracting snapshots and working with time-varying attributes.","category":"section"},{"location":"getting_started.html#Installation","page":"Getting Started","title":"Installation","text":"Install NetworkDynamic.jl from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/Statistical-network-analysis-with-Julia/NetworkDynamic.jl\")","category":"section"},{"location":"getting_started.html#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"The typical NetworkDynamic.jl workflow consists of four steps:\n\nCreate a dynamic network - Define the base structure and observation period\nAdd activity spells - Specify when vertices and edges are active\nQuery activity - Check what is active at given times\nExtract snapshots - Obtain static networks at specific time points","category":"section"},{"location":"getting_started.html#Step-1:-Create-a-Dynamic-Network","page":"Getting Started","title":"Step 1: Create a Dynamic Network","text":"A dynamic network wraps a static Network with temporal information:\n\nusing NetworkDynamic\n\n# Create a directed dynamic network with 5 vertices\ndnet = DynamicNetwork{Int, Float64}(5;\n    observation_start=0.0,\n    observation_end=100.0\n)\n\n# Simplified constructor (defaults to Int vertices, Float64 time)\ndnet = DynamicNetwork(5;\n    observation_start=0.0,\n    observation_end=100.0\n)","category":"section"},{"location":"getting_started.html#Type-Parameters","page":"Getting Started","title":"Type Parameters","text":"Parameter Description Default\nT Vertex ID type (Int, Int32) Int\nTime Timestamp type (Float64, DateTime) Float64","category":"section"},{"location":"getting_started.html#Constructor-Options","page":"Getting Started","title":"Constructor Options","text":"Option Description Default\nobservation_start Start of observation window 0.0\nobservation_end End of observation window 1.0\ndirected Whether the network is directed true\n\n# Undirected dynamic network\ndnet = DynamicNetwork(10;\n    observation_start=0.0,\n    observation_end=50.0,\n    directed=false\n)","category":"section"},{"location":"getting_started.html#Using-DateTime","page":"Getting Started","title":"Using DateTime","text":"For calendar-based timestamps:\n\nusing Dates\n\ndnet = DynamicNetwork{Int, DateTime}(10;\n    observation_start=DateTime(2024, 1, 1),\n    observation_end=DateTime(2024, 12, 31)\n)","category":"section"},{"location":"getting_started.html#Step-2:-Add-Activity-Spells","page":"Getting Started","title":"Step 2: Add Activity Spells","text":"Activity spells define when vertices and edges are active.","category":"section"},{"location":"getting_started.html#Activating-Vertices","page":"Getting Started","title":"Activating Vertices","text":"# Activate vertex 1 from time 0.0 to 50.0\nactivate!(dnet, 0.0, 50.0; vertex=1)\n\n# Activate vertex 2 from time 0.0 to 100.0\nactivate!(dnet, 0.0, 100.0; vertex=2)\n\n# Activate multiple vertices at once\nactivate_vertices!(dnet, [3, 4, 5], 0.0, 100.0)","category":"section"},{"location":"getting_started.html#Activating-Edges","page":"Getting Started","title":"Activating Edges","text":"# Activate edge from vertex 1 to vertex 2\nactivate!(dnet, 5.0, 30.0; edge=(1, 2))\n\n# Activate edge from vertex 2 to vertex 3\nactivate!(dnet, 10.0, 50.0; edge=(2, 3))\n\n# Activate multiple edges at once\nactivate_edges!(dnet, [(3, 4), (4, 5)], 20.0, 80.0)","category":"section"},{"location":"getting_started.html#Multiple-Spells","page":"Getting Started","title":"Multiple Spells","text":"A vertex or edge can have multiple activity spells (e.g., intermittent activity):\n\n# Vertex 1 is active in two separate periods\nactivate!(dnet, 0.0, 30.0; vertex=1)\nactivate!(dnet, 50.0, 80.0; vertex=1)\n\n# Edge (1,2) is active intermittently\nactivate!(dnet, 5.0, 20.0; edge=(1, 2))\nactivate!(dnet, 40.0, 60.0; edge=(1, 2))","category":"section"},{"location":"getting_started.html#Using-Spell-Objects-Directly","page":"Getting Started","title":"Using Spell Objects Directly","text":"For more control, create Spell objects:\n\n# Create a spell with censoring information\ns = Spell(0.0, 50.0; onset_censored=true)  # May have started earlier\n\n# Add spell to vertex\nadd_spell!(dnet, s; vertex=1)\n\n# Add spell to edge\nadd_spell!(dnet, Spell(10.0, 30.0); edge=(1, 2))","category":"section"},{"location":"getting_started.html#Step-3:-Query-Activity","page":"Getting Started","title":"Step 3: Query Activity","text":"","category":"section"},{"location":"getting_started.html#Point-Queries","page":"Getting Started","title":"Point Queries","text":"Check if an element is active at a specific time:\n\n# Is vertex 1 active at time 25?\nis_active(dnet, 25.0; vertex=1)  # true\n\n# Is edge (1,2) active at time 25?\nis_active(dnet, 25.0; edge=(1, 2))  # depends on spells","category":"section"},{"location":"getting_started.html#Interval-Queries","page":"Getting Started","title":"Interval Queries","text":"Check activity during a time interval:\n\n# Is vertex 1 active at ANY point during [10, 40]?\nis_active(dnet, 10.0, 40.0; vertex=1, rule=:any)  # true\n\n# Is vertex 1 active THROUGHOUT [10, 40]?\nis_active(dnet, 10.0, 40.0; vertex=1, rule=:all)  # depends on spells","category":"section"},{"location":"getting_started.html#Listing-Active-Elements","page":"Getting Started","title":"Listing Active Elements","text":"# Get all vertices active at time 25\nactive_verts = active_vertices(dnet, 25.0)\nprintln(\"Active vertices: \", active_verts)\n\n# Get all edges active at time 25\nactive_edgs = active_edges(dnet, 25.0)\nprintln(\"Active edges: \", active_edgs)","category":"section"},{"location":"getting_started.html#Retrieving-Spells","page":"Getting Started","title":"Retrieving Spells","text":"# Get all spells for vertex 1\nspells = get_spells(dnet; vertex=1)\nfor s in spells\n    println(\"Active from $(s.onset) to $(s.terminus)\")\nend\n\n# Convenience aliases\nspells = when_vertex(dnet, 1)\nspells = when_edge(dnet, 1, 2)","category":"section"},{"location":"getting_started.html#Step-4:-Extract-Network-Snapshots","page":"Getting Started","title":"Step 4: Extract Network Snapshots","text":"","category":"section"},{"location":"getting_started.html#At-a-Single-Time-Point","page":"Getting Started","title":"At a Single Time Point","text":"# Extract static network at time 25\nsnapshot = network_extract(dnet, 25.0)\n\n# The result is a standard Network{Int}\nprintln(\"Vertices: \", nv(snapshot))\nprintln(\"Edges: \", ne(snapshot))","category":"section"},{"location":"getting_started.html#Over-a-Time-Interval","page":"Getting Started","title":"Over a Time Interval","text":"# Extract network with any activity during [10, 30]\nsnapshot_any = network_extract(dnet, 10.0, 30.0; rule=:any)\n\n# Extract network active throughout [10, 30]\nsnapshot_all = network_extract(dnet, 10.0, 30.0; rule=:all)","category":"section"},{"location":"getting_started.html#Sequence-of-Snapshots","page":"Getting Started","title":"Sequence of Snapshots","text":"# Extract snapshots at regular intervals\ntimes = collect(0.0:10.0:100.0)\nsnapshots = network_slice(dnet, times)\n\nfor (t, snap) in zip(times, snapshots)\n    println(\"t=$t: $(nv(snap)) vertices, $(ne(snap)) edges\")\nend","category":"section"},{"location":"getting_started.html#Collapse-to-Static","page":"Getting Started","title":"Collapse to Static","text":"# Get a static network with all ever-active elements\nstatic = network_collapse(dnet)\nprintln(\"Total ever-active edges: \", ne(static))","category":"section"},{"location":"getting_started.html#Working-with-Time-Varying-Attributes","page":"Getting Started","title":"Working with Time-Varying Attributes","text":"","category":"section"},{"location":"getting_started.html#Setting-Attributes","page":"Getting Started","title":"Setting Attributes","text":"# Set a time-varying vertex attribute\nset_vertex_attribute_active!(dnet, 1, :status, \"susceptible\", 0.0, 10.0)\nset_vertex_attribute_active!(dnet, 1, :status, \"infected\", 10.0, 30.0)\nset_vertex_attribute_active!(dnet, 1, :status, \"recovered\", 30.0, 100.0)\n\n# Set a time-varying edge attribute\nset_edge_attribute_active!(dnet, 1, 2, :weight, 1.0, 5.0, 20.0)\nset_edge_attribute_active!(dnet, 1, 2, :weight, 2.5, 20.0, 50.0)","category":"section"},{"location":"getting_started.html#Getting-Attributes","page":"Getting Started","title":"Getting Attributes","text":"# Get attribute at a specific time\nstatus = get_vertex_attribute_active(dnet, 1, :status, 15.0)\nprintln(status)  # \"infected\"\n\nstatus = get_vertex_attribute_active(dnet, 1, :status, 35.0)\nprintln(status)  # \"recovered\"\n\n# Get edge attribute at a time\nw = get_edge_attribute_active(dnet, 1, 2, :weight, 10.0)\nprintln(w)  # 1.0","category":"section"},{"location":"getting_started.html#Listing-Available-Attributes","page":"Getting Started","title":"Listing Available Attributes","text":"# What time-varying vertex attributes exist?\nattrs = list_vertex_attributes_active(dnet)\nprintln(\"Vertex TEAs: \", attrs)\n\n# What time-varying edge attributes exist?\nedge_attrs = list_edge_attributes_active(dnet)\nprintln(\"Edge TEAs: \", edge_attrs)","category":"section"},{"location":"getting_started.html#Complete-Example","page":"Getting Started","title":"Complete Example","text":"using NetworkDynamic\n\n# Create a small dynamic network representing a classroom\ndnet = DynamicNetwork(5;\n    observation_start=0.0,\n    observation_end=60.0  # 60-minute class\n)\n\n# All students present for the full class\nactivate_vertices!(dnet, [1, 2, 3, 4, 5], 0.0, 60.0)\n\n# Communication edges (who talks to whom and when)\nactivate!(dnet, 0.0, 15.0; edge=(1, 2))    # 1 talks to 2 early\nactivate!(dnet, 10.0, 30.0; edge=(2, 3))   # 2 talks to 3 mid-early\nactivate!(dnet, 20.0, 45.0; edge=(1, 3))   # 1 talks to 3 middle\nactivate!(dnet, 30.0, 55.0; edge=(3, 4))   # 3 talks to 4 mid-late\nactivate!(dnet, 40.0, 60.0; edge=(4, 5))   # 4 talks to 5 late\nactivate!(dnet, 5.0, 50.0; edge=(2, 1))    # 2 reciprocates 1\n\n# Track discussion topic as a time-varying vertex attribute\nfor v in 1:5\n    set_vertex_attribute_active!(dnet, v, :topic, \"intro\", 0.0, 20.0)\n    set_vertex_attribute_active!(dnet, v, :topic, \"main\", 20.0, 45.0)\n    set_vertex_attribute_active!(dnet, v, :topic, \"conclusion\", 45.0, 60.0)\nend\n\n# Extract snapshots at different points in the class\nprintln(\"=== Beginning of class (t=5) ===\")\nsnap1 = network_extract(dnet, 5.0)\nprintln(\"Edges: \", ne(snap1))\n\nprintln(\"\\n=== Middle of class (t=30) ===\")\nsnap2 = network_extract(dnet, 30.0)\nprintln(\"Edges: \", ne(snap2))\n\nprintln(\"\\n=== End of class (t=55) ===\")\nsnap3 = network_extract(dnet, 55.0)\nprintln(\"Edges: \", ne(snap3))\n\n# Summary information\ninfo = get_timing_info(dnet)\nprintln(\"\\n=== Summary ===\")\nprintln(\"Observation period: \", info.observation_period)\nprintln(\"Data range: $(info.data_start) to $(info.data_end)\")\nprintln(\"Vertex spells: \", info.n_vertex_spells)\nprintln(\"Edge spells: \", info.n_edge_spells)","category":"section"},{"location":"getting_started.html#Converting-Between-Static-and-Dynamic","page":"Getting Started","title":"Converting Between Static and Dynamic","text":"","category":"section"},{"location":"getting_started.html#Static-to-Dynamic","page":"Getting Started","title":"Static to Dynamic","text":"using Network\n\n# Create a static network\nnet = Network{Int}(; n=4, directed=true)\nadd_edge!(net, 1, 2)\nadd_edge!(net, 2, 3)\nadd_edge!(net, 3, 4)\n\n# Convert to dynamic with all elements active from 0 to 100\ndnet = as_dynamic_network(net; onset=0.0, terminus=100.0)","category":"section"},{"location":"getting_started.html#Dynamic-to-Static","page":"Getting Started","title":"Dynamic to Static","text":"# Collapse to static (all ever-active elements)\nstatic = network_collapse(dnet)\n\n# Or extract at a specific time\nstatic_at_50 = network_extract(dnet, 50.0)","category":"section"},{"location":"getting_started.html#Ensuring-Consistency","page":"Getting Started","title":"Ensuring Consistency","text":"Edge activity should be consistent with vertex activity – an edge can only be active when both endpoints are active:\n\n# After modifying vertex spells, reconcile edge activity\nreconcile_activity!(dnet)","category":"section"},{"location":"getting_started.html#Best-Practices","page":"Getting Started","title":"Best Practices","text":"Set the observation period: Always specify observation_start and observation_end\nActivate vertices before edges: Ensure endpoints are active before adding edge spells\nUse reconcile_activity!: After modifying vertex spells, ensure edge consistency\nMerge overlapping spells: Call merge_spells! to simplify spell lists\nUse appropriate time types: Float64 for abstract time, DateTime for calendar time\nExtract snapshots for analysis: Use network_extract to get static networks for SNA functions","category":"section"},{"location":"getting_started.html#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn about Dynamic Networks in detail\nUnderstand Spells and Activity operations\nMaster Time Queries for extracting and querying temporal data","category":"section"},{"location":"guide/dynamic_networks.html#Dynamic-Networks","page":"Dynamic Networks","title":"Dynamic Networks","text":"This guide covers the DynamicNetwork type in detail, including its structure, construction, and relationship to static networks.","category":"section"},{"location":"guide/dynamic_networks.html#The-DynamicNetwork-Type","page":"Dynamic Networks","title":"The DynamicNetwork Type","text":"A DynamicNetwork{T, Time} wraps a static Network{T} with temporal information. It has two type parameters:\n\nT: The vertex ID type (typically Int)\nTime: The timestamp type (Float64, DateTime, Date, or any ordered type)","category":"section"},{"location":"guide/dynamic_networks.html#Internal-Structure","page":"Dynamic Networks","title":"Internal Structure","text":"mutable struct DynamicNetwork{T<:Integer, Time}\n    network::Network{T}                                  # Base static network\n    vertex_spells::Dict{T, Vector{Spell{Time}}}           # Vertex activity\n    edge_spells::Dict{Tuple{T,T}, Vector{Spell{Time}}}    # Edge activity\n    vertex_tea::Dict{Tuple{T,Symbol}, TimeVaryingAttribute}  # Vertex TEAs\n    edge_tea::Dict{Tuple{Tuple{T,T},Symbol}, TimeVaryingAttribute}  # Edge TEAs\n    observation_period::Tuple{Time, Time}                 # Observation window\n    net_obs_period::Spell{Time}                           # Same as Spell\nend\n\nThe underlying network field stores the maximum set of vertices and edges – those that are ever active. Activity spells then restrict which elements exist at any given time.","category":"section"},{"location":"guide/dynamic_networks.html#Creating-Dynamic-Networks","page":"Dynamic Networks","title":"Creating Dynamic Networks","text":"","category":"section"},{"location":"guide/dynamic_networks.html#Basic-Construction","page":"Dynamic Networks","title":"Basic Construction","text":"using NetworkDynamic\n\n# Specify type parameters explicitly\ndnet = DynamicNetwork{Int, Float64}(10;\n    observation_start=0.0,\n    observation_end=100.0\n)\n\n# Use defaults (Int vertices, Float64 time)\ndnet = DynamicNetwork(10;\n    observation_start=0.0,\n    observation_end=100.0\n)\n\n# Empty network (0 vertices)\ndnet = DynamicNetwork(;\n    observation_start=0.0,\n    observation_end=50.0\n)","category":"section"},{"location":"guide/dynamic_networks.html#Directed-vs.-Undirected","page":"Dynamic Networks","title":"Directed vs. Undirected","text":"# Directed network (default)\ndnet_dir = DynamicNetwork(5;\n    observation_start=0.0,\n    observation_end=10.0,\n    directed=true\n)\n\n# Undirected network\ndnet_undir = DynamicNetwork(5;\n    observation_start=0.0,\n    observation_end=10.0,\n    directed=false\n)\n\nFor undirected networks, edge keys are normalized so that (min(i,j), max(i,j)) is always used. This means activate!(dnet, 0.0, 5.0; edge=(3, 1)) and activate!(dnet, 0.0, 5.0; edge=(1, 3)) refer to the same edge.","category":"section"},{"location":"guide/dynamic_networks.html#With-DateTime-Timestamps","page":"Dynamic Networks","title":"With DateTime Timestamps","text":"using Dates\n\ndnet = DynamicNetwork{Int, DateTime}(20;\n    observation_start=DateTime(2024, 1, 1),\n    observation_end=DateTime(2024, 12, 31)\n)\n\n# Add activity spells with DateTime\nactivate!(dnet, DateTime(2024, 1, 1), DateTime(2024, 6, 30); vertex=1)\nactivate!(dnet, DateTime(2024, 3, 1), DateTime(2024, 9, 30); edge=(1, 2))","category":"section"},{"location":"guide/dynamic_networks.html#With-Date-Timestamps","page":"Dynamic Networks","title":"With Date Timestamps","text":"using Dates\n\ndnet = DynamicNetwork{Int, Date}(10;\n    observation_start=Date(2024, 1, 1),\n    observation_end=Date(2024, 12, 31)\n)\n\nactivate!(dnet, Date(2024, 1, 1), Date(2024, 6, 30); vertex=1)","category":"section"},{"location":"guide/dynamic_networks.html#The-Observation-Period","page":"Dynamic Networks","title":"The Observation Period","text":"The observation period defines the overall time window for the network. It does not constrain spell activity (spells can extend beyond the observation period), but it provides context for analysis.","category":"section"},{"location":"guide/dynamic_networks.html#Getting-and-Setting","page":"Dynamic Networks","title":"Getting and Setting","text":"# Get current observation period\nperiod = get_observation_period(dnet)\nprintln(\"Start: $(period[1]), End: $(period[2])\")\n\n# Update observation period\nset_observation_period!(dnet, 0.0, 200.0)","category":"section"},{"location":"guide/dynamic_networks.html#Timing-Information","page":"Dynamic Networks","title":"Timing Information","text":"Get comprehensive timing statistics:\n\ninfo = get_timing_info(dnet)\n\nprintln(\"Observation period: \", info.observation_period)\nprintln(\"Earliest data: \", info.data_start)\nprintln(\"Latest data: \", info.data_end)\nprintln(\"Vertex spells: \", info.n_vertex_spells)\nprintln(\"Edge spells: \", info.n_edge_spells)\n\nThe data_start and data_end fields reflect the actual range of spell data, which may differ from the observation period.","category":"section"},{"location":"guide/dynamic_networks.html#Graphs.jl-Interface","page":"Dynamic Networks","title":"Graphs.jl Interface","text":"DynamicNetwork forwards key Graphs.jl queries to its underlying Network:\n\nusing Graphs\n\nnv(dnet)            # Total number of vertices (maximum set)\nne(dnet)            # Total number of edges (maximum set)\nvertices(dnet)      # Iterate over all vertex IDs\nis_directed(dnet)   # Check if directed\n\nThese operate on the maximum set of vertices and edges, not the active set at any particular time. To get the active set, use network_extract.","category":"section"},{"location":"guide/dynamic_networks.html#Network-Extraction","page":"Dynamic Networks","title":"Network Extraction","text":"Network extraction produces a static Network{T} from a DynamicNetwork at a given time or during an interval.","category":"section"},{"location":"guide/dynamic_networks.html#Point-Extraction","page":"Dynamic Networks","title":"Point Extraction","text":"# Static network at time 25.0\nsnapshot = network_extract(dnet, 25.0)\n\n# Use with any Graphs.jl function\nprintln(\"Active vertices: \", nv(snapshot))\nprintln(\"Active edges: \", ne(snapshot))\nprintln(\"Density: \", ne(snapshot) / (nv(snapshot) * (nv(snapshot) - 1)))\n\nVertices and edges are re-indexed in the extracted network. If vertices 2, 4, and 5 are active, they become vertices 1, 2, and 3 in the snapshot.","category":"section"},{"location":"guide/dynamic_networks.html#Interval-Extraction","page":"Dynamic Networks","title":"Interval Extraction","text":"# Any activity during [10, 30] -- union of active elements\nsnapshot_any = network_extract(dnet, 10.0, 30.0; rule=:any)\n\n# Active throughout [10, 30] -- intersection\nsnapshot_all = network_extract(dnet, 10.0, 30.0; rule=:all)\n\nThe :any rule includes any element active at any point during the interval. The :all rule requires continuous activity throughout.","category":"section"},{"location":"guide/dynamic_networks.html#Slice-and-Collapse","page":"Dynamic Networks","title":"Slice and Collapse","text":"# Extract a sequence of snapshots\ntimes = collect(0.0:5.0:50.0)\nsnapshots = network_slice(dnet, times)\n\n# Collapse to static (union of all ever-active elements)\nstatic = network_collapse(dnet)","category":"section"},{"location":"guide/dynamic_networks.html#Converting-from-Static-Networks","page":"Dynamic Networks","title":"Converting from Static Networks","text":"Convert an existing static Network to a DynamicNetwork:\n\nusing Network\n\n# Create static network\nnet = Network{Int}(; n=5, directed=true)\nadd_edge!(net, 1, 2)\nadd_edge!(net, 2, 3)\nadd_edge!(net, 3, 1)\n\n# Convert: all elements active during [0, 100]\ndnet = as_dynamic_network(net; onset=0.0, terminus=100.0)\n\n# Verify\nprintln(\"Vertex spells for v=1: \", get_spells(dnet; vertex=1))\nprintln(\"Edge spells for (1,2): \", get_spells(dnet; edge=(1, 2)))","category":"section"},{"location":"guide/dynamic_networks.html#Reconciling-Activity","page":"Dynamic Networks","title":"Reconciling Activity","text":"Edge activity should be consistent with vertex activity. An edge (i, j) can only be active when both vertices i and j are active. After modifying vertex spells, call reconcile_activity! to enforce this constraint:\n\n# Initial setup\nactivate!(dnet, 0.0, 50.0; vertex=1)\nactivate!(dnet, 0.0, 100.0; vertex=2)\nactivate!(dnet, 0.0, 80.0; edge=(1, 2))\n\n# Vertex 1 is only active until t=50, but edge (1,2) is marked active until t=80\n# reconcile_activity! will trim the edge spell to [0, 50]\nreconcile_activity!(dnet)\n\n# After reconciliation, edge (1,2) is only active during [0, 50]\nspells = get_spells(dnet; edge=(1, 2))\nprintln(spells)  # Spell(0.0, 50.0)","category":"section"},{"location":"guide/dynamic_networks.html#How-Reconciliation-Works","page":"Dynamic Networks","title":"How Reconciliation Works","text":"For each edge spell, the function computes the intersection with the vertex activity of both endpoints. If neither endpoint has vertex spells defined, the edge is assumed to be valid (vertices are always active).\n\n# Example: Edge intersected with vertex activity\n# Vertex 1: active [0, 30] and [50, 80]\n# Vertex 2: active [10, 90]\n# Edge (1,2): active [0, 100]\n# After reconciliation: edge active [10, 30] and [50, 80]\n#   (intersection of edge spell with both vertex spells)","category":"section"},{"location":"guide/dynamic_networks.html#Building-Dynamic-Networks-from-Data","page":"Dynamic Networks","title":"Building Dynamic Networks from Data","text":"","category":"section"},{"location":"guide/dynamic_networks.html#From-a-List-of-Edges-with-Times","page":"Dynamic Networks","title":"From a List of Edges with Times","text":"# Edge data: (source, target, onset, terminus)\nedge_data = [\n    (1, 2, 0.0, 10.0),\n    (2, 3, 5.0, 15.0),\n    (1, 3, 10.0, 20.0),\n    (3, 4, 15.0, 25.0),\n]\n\n# Create network\nn_vertices = 4\ndnet = DynamicNetwork(n_vertices;\n    observation_start=0.0,\n    observation_end=30.0\n)\n\n# Activate all vertices for the full period\nactivate_vertices!(dnet, collect(1:n_vertices), 0.0, 30.0)\n\n# Add edge spells\nfor (i, j, onset, terminus) in edge_data\n    activate!(dnet, onset, terminus; edge=(i, j))\nend","category":"section"},{"location":"guide/dynamic_networks.html#From-Panel-Data-(Discrete-Time)","page":"Dynamic Networks","title":"From Panel Data (Discrete Time)","text":"When you have a sequence of static networks at fixed time points:\n\nusing Network\n\n# Suppose you have networks at times 1, 2, 3\nnets = [net_t1, net_t2, net_t3]\nn = nv(nets[1])\n\ndnet = DynamicNetwork(n;\n    observation_start=1.0,\n    observation_end=4.0  # one past last time point\n)\n\n# Activate all vertices for the full period\nactivate_vertices!(dnet, collect(1:n), 1.0, 4.0)\n\n# Add edge spells from each time step\nfor (t, net) in enumerate(nets)\n    for e in edges(net)\n        activate!(dnet, Float64(t), Float64(t + 1); edge=(src(e), dst(e)))\n    end\nend\n\n# Merge adjacent spells for edges that persist across time points\nfor ((i, j), _) in dnet.edge_spells\n    merge_spells!(dnet; edge=(i, j))\nend","category":"section"},{"location":"guide/dynamic_networks.html#Memory-and-Performance","page":"Dynamic Networks","title":"Memory and Performance","text":"","category":"section"},{"location":"guide/dynamic_networks.html#Storage-Considerations","page":"Dynamic Networks","title":"Storage Considerations","text":"Each spell object stores onset, terminus, and two boolean flags\nVertex spells are stored in a Dict{T, Vector{Spell{Time}}}\nEdge spells are stored in a Dict{Tuple{T,T}, Vector{Spell{Time}}}\nTime-varying attributes add additional storage per attribute per spell","category":"section"},{"location":"guide/dynamic_networks.html#Performance-Tips","page":"Dynamic Networks","title":"Performance Tips","text":"Merge spells: Call merge_spells! to reduce the number of spell objects when overlapping spells accumulate\nExtract once: If you need the same snapshot repeatedly, extract it once and reuse the Network object\nUse appropriate time types: Float64 is faster than DateTime for arithmetic\nPre-allocate vertices: Specify the vertex count at construction time rather than growing incrementally","category":"section"},{"location":"guide/dynamic_networks.html#Printing-and-Inspection","page":"Dynamic Networks","title":"Printing and Inspection","text":"# Basic info\nprintln(\"Vertices: \", nv(dnet))\nprintln(\"Edges: \", ne(dnet))\nprintln(\"Directed: \", is_directed(dnet))\nprintln(\"Observation: \", get_observation_period(dnet))\n\n# Detailed timing\ninfo = get_timing_info(dnet)\nprintln(\"Data range: $(info.data_start) to $(info.data_end)\")\nprintln(\"Vertex spells: $(info.n_vertex_spells)\")\nprintln(\"Edge spells: $(info.n_edge_spells)\")\n\n# Inspect specific elements\nfor v in 1:nv(dnet)\n    spells = when_vertex(dnet, v)\n    if !isempty(spells)\n        println(\"Vertex $v: \", spells)\n    end\nend","category":"section"},{"location":"guide/queries.html#Time-Queries","page":"Time Queries","title":"Time Queries","text":"This guide covers how to query activity status, extract network snapshots, and work with time-varying attributes in NetworkDynamic.jl.","category":"section"},{"location":"guide/queries.html#Activity-Queries","page":"Time Queries","title":"Activity Queries","text":"","category":"section"},{"location":"guide/queries.html#Point-in-Time-Queries","page":"Time Queries","title":"Point-in-Time Queries","text":"The most basic query checks whether a vertex or edge is active at a specific time:\n\nusing NetworkDynamic\n\ndnet = DynamicNetwork(5; observation_start=0.0, observation_end=50.0)\nactivate!(dnet, 0.0, 30.0; vertex=1)\nactivate!(dnet, 10.0, 50.0; vertex=2)\nactivate!(dnet, 5.0, 25.0; edge=(1, 2))\n\n# Point queries\nis_active(dnet, 10.0; vertex=1)   # true  (0 <= 10 < 30)\nis_active(dnet, 35.0; vertex=1)   # false (30 <= 35)\nis_active(dnet, 10.0; edge=(1, 2)) # true  (5 <= 10 < 25)\n\nThe spell is half-open: onset <= t < terminus. This means an element becomes inactive exactly at its terminus time.","category":"section"},{"location":"guide/queries.html#Interval-Queries","page":"Time Queries","title":"Interval Queries","text":"Check activity over a time interval with two rules:\n\n# Rule :any -- active at ANY point during [10, 35]\nis_active(dnet, 10.0, 35.0; vertex=1, rule=:any)  # true (overlaps with [0, 30))\n\n# Rule :all -- active THROUGHOUT [10, 35]\nis_active(dnet, 10.0, 35.0; vertex=1, rule=:all)  # false (not active at t=30)\n\n# Active throughout [10, 25]\nis_active(dnet, 10.0, 25.0; vertex=1, rule=:all)  # true (contained in [0, 30))\n\nRule Meaning Condition\n:any Active at any point in the interval Any spell overlaps with [onset, terminus)\n:all Active throughout the entire interval Some spell contains [onset, terminus)","category":"section"},{"location":"guide/queries.html#Listing-Active-Elements","page":"Time Queries","title":"Listing Active Elements","text":"Get all active vertices or edges at a time:\n\n# All vertices active at t=15\nverts = active_vertices(dnet, 15.0)\nprintln(\"Active vertices: \", verts)\n\n# All edges active at t=15\nedgs = active_edges(dnet, 15.0)\nprintln(\"Active edges: \", edgs)\n\nThese functions are useful for computing cross-sectional network statistics at specific time points.","category":"section"},{"location":"guide/queries.html#Complete-Activity-History","page":"Time Queries","title":"Complete Activity History","text":"Retrieve all spells for an element:\n\n# All spells for vertex 1\nspells = when_vertex(dnet, 1)\nfor s in spells\n    println(\"Active from $(s.onset) to $(s.terminus), duration: $(spell_duration(s))\")\nend\n\n# All spells for edge (1, 2)\nspells = when_edge(dnet, 1, 2)\n\n# Activity range (earliest onset to latest terminus)\nrange = get_activity_range(dnet; vertex=1)\nprintln(\"First active: $(range[1]), Last active: $(range[2])\")","category":"section"},{"location":"guide/queries.html#Network-Extraction","page":"Time Queries","title":"Network Extraction","text":"","category":"section"},{"location":"guide/queries.html#Point-Extraction","page":"Time Queries","title":"Point Extraction","text":"Extract a static Network representing the state at a single time:\n\n# Snapshot at t=15\nsnapshot = network_extract(dnet, 15.0)\n\n# Use with standard network functions\nprintln(\"Vertices: \", nv(snapshot))\nprintln(\"Edges: \", ne(snapshot))\n\n# Use with Graphs.jl algorithms\nusing Graphs\ncc = connected_components(snapshot)\nprintln(\"Components: \", length(cc))","category":"section"},{"location":"guide/queries.html#Vertex-Re-indexing","page":"Time Queries","title":"Vertex Re-indexing","text":"When extracting a snapshot, only active vertices are included, and they are re-indexed starting from 1. Static vertex attributes from the underlying network are carried over.\n\n# If vertices 2, 5, 8 are active at t=10\n# They become vertices 1, 2, 3 in the extracted network\nsnapshot = network_extract(dnet, 10.0)\n# nv(snapshot) == 3","category":"section"},{"location":"guide/queries.html#Interval-Extraction","page":"Time Queries","title":"Interval Extraction","text":"Extract a network representing activity over a time range:\n\n# Any activity during [10, 30]: includes elements active at any point\nsnapshot_any = network_extract(dnet, 10.0, 30.0; rule=:any)\n\n# Active throughout [10, 30]: only elements continuously active\nsnapshot_all = network_extract(dnet, 10.0, 30.0; rule=:all)\n\nUse cases:\n\n:any – aggregate view of \"who interacted during this period\"\n:all – stable ties that persisted throughout the period","category":"section"},{"location":"guide/queries.html#Time-Series-of-Snapshots","page":"Time Queries","title":"Time Series of Snapshots","text":"Extract snapshots at regular intervals for temporal analysis:\n\n# Snapshots every 10 time units\ntimes = collect(0.0:10.0:100.0)\nsnapshots = network_slice(dnet, times)\n\n# Compute density time series\ndensities = Float64[]\nfor snap in snapshots\n    n = nv(snap)\n    if n > 1\n        max_e = is_directed(snap) ? n * (n - 1) : n * (n - 1) / 2\n        push!(densities, ne(snap) / max_e)\n    else\n        push!(densities, 0.0)\n    end\nend\n\nfor (t, d) in zip(times, densities)\n    println(\"t=$t: density = $(round(d, digits=3))\")\nend","category":"section"},{"location":"guide/queries.html#Collapsing-to-Static","page":"Time Queries","title":"Collapsing to Static","text":"Collapse the entire dynamic network to a single static network:\n\n# All elements that were ever active\nstatic = network_collapse(dnet)\nprintln(\"Ever-active edges: \", ne(static))","category":"section"},{"location":"guide/queries.html#Time-Varying-Attributes","page":"Time Queries","title":"Time-Varying Attributes","text":"Time-varying attributes (TEAs) are attributes whose values change over time. Each value is associated with a spell during which it is valid.","category":"section"},{"location":"guide/queries.html#Setting-Vertex-TEAs","page":"Time Queries","title":"Setting Vertex TEAs","text":"# Disease status changes over time\nset_vertex_attribute_active!(dnet, 1, :status, \"susceptible\", 0.0, 10.0)\nset_vertex_attribute_active!(dnet, 1, :status, \"infected\", 10.0, 25.0)\nset_vertex_attribute_active!(dnet, 1, :status, \"recovered\", 25.0, 100.0)\n\n# Numeric attribute\nset_vertex_attribute_active!(dnet, 1, :risk_score, 0.1, 0.0, 10.0)\nset_vertex_attribute_active!(dnet, 1, :risk_score, 0.9, 10.0, 25.0)\nset_vertex_attribute_active!(dnet, 1, :risk_score, 0.05, 25.0, 100.0)","category":"section"},{"location":"guide/queries.html#Getting-Vertex-TEAs","page":"Time Queries","title":"Getting Vertex TEAs","text":"# Query at a specific time\nstatus = get_vertex_attribute_active(dnet, 1, :status, 5.0)\nprintln(status)  # \"susceptible\"\n\nstatus = get_vertex_attribute_active(dnet, 1, :status, 15.0)\nprintln(status)  # \"infected\"\n\nstatus = get_vertex_attribute_active(dnet, 1, :status, 50.0)\nprintln(status)  # \"recovered\"\n\n# Returns nothing if no value is defined at that time\nval = get_vertex_attribute_active(dnet, 1, :unknown, 5.0)\nprintln(val)  # nothing","category":"section"},{"location":"guide/queries.html#Edge-TEAs","page":"Time Queries","title":"Edge TEAs","text":"# Set time-varying edge weight\nset_edge_attribute_active!(dnet, 1, 2, :weight, 1.0, 5.0, 15.0)\nset_edge_attribute_active!(dnet, 1, 2, :weight, 3.5, 15.0, 25.0)\n\n# Query\nw = get_edge_attribute_active(dnet, 1, 2, :weight, 10.0)\nprintln(w)  # 1.0\n\nw = get_edge_attribute_active(dnet, 1, 2, :weight, 20.0)\nprintln(w)  # 3.5","category":"section"},{"location":"guide/queries.html#Listing-TEAs","page":"Time Queries","title":"Listing TEAs","text":"# All time-varying vertex attribute names\nvertex_teas = list_vertex_attributes_active(dnet)\nprintln(\"Vertex TEAs: \", vertex_teas)  # [:status, :risk_score]\n\n# All time-varying edge attribute names\nedge_teas = list_edge_attributes_active(dnet)\nprintln(\"Edge TEAs: \", edge_teas)  # [:weight]","category":"section"},{"location":"guide/queries.html#Practical-Examples","page":"Time Queries","title":"Practical Examples","text":"","category":"section"},{"location":"guide/queries.html#Tracking-Network-Evolution","page":"Time Queries","title":"Tracking Network Evolution","text":"using NetworkDynamic\n\n# Create a growing network\ndnet = DynamicNetwork(10; observation_start=0.0, observation_end=100.0)\nactivate_vertices!(dnet, collect(1:10), 0.0, 100.0)\n\n# Edges form progressively\nactivate!(dnet, 0.0, 100.0; edge=(1, 2))\nactivate!(dnet, 10.0, 100.0; edge=(2, 3))\nactivate!(dnet, 20.0, 100.0; edge=(3, 4))\nactivate!(dnet, 30.0, 100.0; edge=(4, 5))\nactivate!(dnet, 40.0, 100.0; edge=(5, 6))\nactivate!(dnet, 50.0, 80.0; edge=(6, 7))   # Temporary edge\nactivate!(dnet, 60.0, 100.0; edge=(7, 8))\nactivate!(dnet, 70.0, 100.0; edge=(8, 9))\nactivate!(dnet, 80.0, 100.0; edge=(9, 10))\n\n# Track growth over time\nfor t in 0.0:10.0:100.0\n    edgs = active_edges(dnet, t)\n    println(\"t=$t: $(length(edgs)) active edges\")\nend","category":"section"},{"location":"guide/queries.html#Epidemic-Simulation-Data","page":"Time Queries","title":"Epidemic Simulation Data","text":"# SIR model data\ndnet = DynamicNetwork(20; observation_start=0.0, observation_end=50.0)\nactivate_vertices!(dnet, collect(1:20), 0.0, 50.0)\n\n# Set initial states\nfor v in 1:20\n    set_vertex_attribute_active!(dnet, v, :state, \"S\", 0.0, 50.0)\nend\n\n# Patient zero infected at t=0\nset_vertex_attribute_active!(dnet, 1, :state, \"I\", 0.0, 10.0)\nset_vertex_attribute_active!(dnet, 1, :state, \"R\", 10.0, 50.0)\n\n# Check state at any time\nfor v in [1, 5, 10]\n    state = get_vertex_attribute_active(dnet, v, :state, 5.0)\n    println(\"Vertex $v at t=5: $state\")\nend","category":"section"},{"location":"guide/queries.html#Window-Based-Analysis","page":"Time Queries","title":"Window-Based Analysis","text":"# Analyze the network in non-overlapping windows\nwindow_size = 10.0\nstart, stop = get_observation_period(dnet)\n\nt = start\nwhile t + window_size <= stop\n    snap = network_extract(dnet, t, t + window_size; rule=:any)\n    println(\"Window [$t, $(t + window_size)): $(nv(snap)) vertices, $(ne(snap)) edges\")\n    t += window_size\nend","category":"section"},{"location":"guide/queries.html#Summary-of-Query-Functions","page":"Time Queries","title":"Summary of Query Functions","text":"Function Returns Description\nis_active(dnet, t; vertex=v) Bool Is vertex active at time t?\nis_active(dnet, t; edge=(i,j)) Bool Is edge active at time t?\nis_active(dnet, t1, t2; vertex=v, rule=r) Bool Is vertex active during interval?\nactive_vertices(dnet, t) Vector{T} All active vertices at time t\nactive_edges(dnet, t) Vector{Tuple} All active edges at time t\nget_spells(dnet; vertex=v) Vector{Spell} All spells for a vertex\nwhen_vertex(dnet, v) Vector{Spell} Alias for get_spells vertex\nwhen_edge(dnet, i, j) Vector{Spell} Alias for get_spells edge\nget_activity_range(dnet; vertex=v) Tuple Earliest onset to latest terminus\nnetwork_extract(dnet, t) Network Static snapshot at time t\nnetwork_extract(dnet, t1, t2) Network Static snapshot over interval\nnetwork_slice(dnet, times) Vector{Network} Multiple snapshots\nnetwork_collapse(dnet) Network All ever-active elements","category":"section"},{"location":"index.html#NetworkDynamic.jl","page":"Home","title":"NetworkDynamic.jl","text":"Dynamic Network Data Structures for Julia\n\nA Julia package for representing and manipulating dynamic (time-varying) networks with activity spells, time-varying attributes, and network extraction at any point in time.","category":"section"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"Dynamic networks are networks whose structure changes over time. Vertices and edges can appear and disappear, and attributes can vary across the observation period. NetworkDynamic.jl provides the data structures needed to represent, query, and manipulate such networks.\n\nNetworkDynamic.jl is a port of the R networkDynamic package from the StatNet collection.","category":"section"},{"location":"index.html#What-is-a-Dynamic-Network?","page":"Home","title":"What is a Dynamic Network?","text":"A dynamic network is a network where the set of active vertices and edges changes over time. Each vertex and edge has one or more activity spells – time intervals during which it is active:\n\nVertex 1:  |=====|     |====|\nVertex 2:  |================|\nEdge 1-2:     |===|     |==|\n             ──────────────────→ time\n             0    5    10   15","category":"section"},{"location":"index.html#Key-Concepts","page":"Home","title":"Key Concepts","text":"Concept Description\nDynamic Network A network with time-varying structure and attributes\nSpell A time interval [onset, terminus) during which an element is active\nActivity Whether a vertex or edge exists at a given time\nNetwork Extraction Obtaining a static snapshot of the network at a point in time\nTime-Varying Attribute A vertex or edge attribute whose value changes over time\nObservation Period The overall time window during which the network is observed","category":"section"},{"location":"index.html#Applications","page":"Home","title":"Applications","text":"Dynamic network data structures are foundational for:\n\nTemporal ERGM (TERGM): Statistical models for network evolution\nTemporal SNA (TSNA): Descriptive analysis of network dynamics\nNetwork visualization: Animating networks over time (NDTV)\nEpidemiology: Modeling disease spread through time-varying contacts\nOrganizational studies: Tracking collaboration network evolution\nOnline platforms: Modeling evolving user interaction networks","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"Activity spells: Track when vertices and edges are active with Spell objects\nTime-varying attributes: Store attributes that change over time\nNetwork extraction: Extract static network snapshots at any time point or over intervals\nSpell operations: Add, remove, merge, and query activity spells\nGraphs.jl integration: Built on Network.jl, which implements the Graphs.jl interface\nFlexible timestamps: Supports Float64, DateTime, Date, and other ordered types\nConversion utilities: Convert between static and dynamic networks","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/Statistical-network-analysis-with-Julia/NetworkDynamic.jl\")\n\nOr for development:\n\nusing Pkg\nPkg.develop(path=\"/path/to/NetworkDynamic.jl\")","category":"section"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"using NetworkDynamic\n\n# Create a dynamic network with 5 vertices\ndnet = DynamicNetwork{Int, Float64}(5;\n    observation_start=0.0,\n    observation_end=10.0\n)\n\n# Activate vertices during specific time intervals\nactivate!(dnet, 0.0, 8.0; vertex=1)\nactivate!(dnet, 0.0, 10.0; vertex=2)\nactivate!(dnet, 2.0, 10.0; vertex=3)\n\n# Activate edges\nactivate!(dnet, 1.0, 5.0; edge=(1, 2))\nactivate!(dnet, 3.0, 7.0; edge=(2, 3))\n\n# Query activity at a time point\nis_active(dnet, 2.0; edge=(1, 2))  # true\nis_active(dnet, 6.0; edge=(1, 2))  # false\n\n# Extract a static snapshot at time 4.0\nsnapshot = network_extract(dnet, 4.0)\n\n# Get timing information\ninfo = get_timing_info(dnet)\nprintln(\"Vertex spells: \", info.n_vertex_spells)\nprintln(\"Edge spells: \", info.n_edge_spells)","category":"section"},{"location":"index.html#Relationship-to-Other-Packages","page":"Home","title":"Relationship to Other Packages","text":"Package Role\nNetwork.jl Static network data structure (dependency)\nNetworkDynamic.jl Dynamic network data structure (this package)\nTERGM.jl Temporal ERGM models (uses NetworkDynamic for data)\nTSNA.jl Temporal SNA descriptive analysis (uses NetworkDynamic for data)\nNDTV.jl Network visualization and animation","category":"section"},{"location":"index.html#Documentation","page":"Home","title":"Documentation","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/dynamic_networks.md\",\n    \"guide/spells.md\",\n    \"guide/queries.md\",\n    \"api/types.md\",\n    \"api/functions.md\",\n]\nDepth = 2","category":"section"},{"location":"index.html#Theoretical-Background","page":"Home","title":"Theoretical Background","text":"","category":"section"},{"location":"index.html#Discrete-vs.-Continuous-Time","page":"Home","title":"Discrete vs. Continuous Time","text":"Dynamic networks can be modeled in two paradigms:\n\nDiscrete time: Network changes at fixed time steps t = 1 2 3 ldots (panel data)\nContinuous time: Changes can occur at any time, represented by spells t_textonset t_textterminus)\n\nNetworkDynamic.jl supports continuous-time representation, which subsumes discrete time as a special case. Continuous-time spells can represent any pattern of activity, including instantaneous events and long-duration ties.","category":"section"},{"location":"index.html#Activity-Algebra","page":"Home","title":"Activity Algebra","text":"Spells follow interval algebra rules:\n\nOverlap: Two spells overlap if s_1textonset  s_2textterminus and s_2textonset  s_1textterminus\nContainment: Spell s_1 contains s_2 if s_1textonset leq s_2textonset and s_1textterminus geq s_2textterminus\nDuration: d(s) = stextterminus - stextonset\nMerging: Overlapping spells can be merged into a single contiguous spell","category":"section"},{"location":"index.html#References","page":"Home","title":"References","text":"Butts, C.T. (2008). network: A package for managing relational data in R. Journal of Statistical Software, 24(2), 1-36.\nAlmquist, Z.W., Butts, C.T. (2014). Logistic network regression for scalable analysis of networks with joint edge/vertex dynamics. Sociological Methodology, 44(1), 273-321.\nBender-deMoll, S., Morris, M. (2012). networkDynamic: Dynamic extensions for network objects. R package.\nHolme, P., Saramaki, J. (2012). Temporal networks. Physics Reports, 519(3), 97-125.","category":"section"},{"location":"api/functions.html#Functions-API-Reference","page":"Functions","title":"Functions API Reference","text":"This page documents all functions available in NetworkDynamic.jl.","category":"section"},{"location":"api/functions.html#Spell-Operations","page":"Functions","title":"Spell Operations","text":"","category":"section"},{"location":"api/functions.html#Adding-Spells","page":"Functions","title":"Adding Spells","text":"","category":"section"},{"location":"api/functions.html#Removing-and-Merging-Spells","page":"Functions","title":"Removing and Merging Spells","text":"","category":"section"},{"location":"api/functions.html#Retrieving-Spells","page":"Functions","title":"Retrieving Spells","text":"","category":"section"},{"location":"api/functions.html#Activity-Queries","page":"Functions","title":"Activity Queries","text":"","category":"section"},{"location":"api/functions.html#Point-and-Interval-Queries","page":"Functions","title":"Point and Interval Queries","text":"","category":"section"},{"location":"api/functions.html#Active-Element-Listing","page":"Functions","title":"Active Element Listing","text":"","category":"section"},{"location":"api/functions.html#Network-Extraction","page":"Functions","title":"Network Extraction","text":"","category":"section"},{"location":"api/functions.html#Time-Varying-Attributes","page":"Functions","title":"Time-Varying Attributes","text":"","category":"section"},{"location":"api/functions.html#Vertex-Attributes","page":"Functions","title":"Vertex Attributes","text":"","category":"section"},{"location":"api/functions.html#Edge-Attributes","page":"Functions","title":"Edge Attributes","text":"","category":"section"},{"location":"api/functions.html#Observation-Period","page":"Functions","title":"Observation Period","text":"","category":"section"},{"location":"api/functions.html#Conversion-and-Reconciliation","page":"Functions","title":"Conversion and Reconciliation","text":"","category":"section"},{"location":"api/functions.html#NetworkDynamic.add_spell!","page":"Functions","title":"NetworkDynamic.add_spell!","text":"add_spell!(dnet::DynamicNetwork, spell::Spell; vertex=nothing, edge=nothing)\n\nAdd an activity spell to a vertex or edge.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.activate!","page":"Functions","title":"NetworkDynamic.activate!","text":"activate!(dnet::DynamicNetwork, onset, terminus; vertex=nothing, edge=nothing)\n\nConvenience function to add a spell from onset to terminus.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.activate_vertices!","page":"Functions","title":"NetworkDynamic.activate_vertices!","text":"activate_vertices!(dnet::DynamicNetwork, vertices, onset, terminus)\n\nActivate multiple vertices for a spell.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.activate_edges!","page":"Functions","title":"NetworkDynamic.activate_edges!","text":"activate_edges!(dnet::DynamicNetwork, edges, onset, terminus)\n\nActivate multiple edges for a spell.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.remove_spell!","page":"Functions","title":"NetworkDynamic.remove_spell!","text":"remove_spell!(dnet::DynamicNetwork, spell::Spell; vertex=nothing, edge=nothing)\n\nRemove a specific spell from a vertex or edge.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.merge_spells!","page":"Functions","title":"NetworkDynamic.merge_spells!","text":"merge_spells!(dnet::DynamicNetwork; vertex=nothing, edge=nothing)\n\nMerge overlapping or adjacent spells for a vertex or edge.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.get_spells","page":"Functions","title":"NetworkDynamic.get_spells","text":"get_spells(dnet::DynamicNetwork; vertex=nothing, edge=nothing) -> Vector{Spell}\n\nGet all activity spells for a vertex or edge.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.when_vertex","page":"Functions","title":"NetworkDynamic.when_vertex","text":"when_vertex(dnet::DynamicNetwork, v) -> Vector{Spell}\n\nGet all activity spells for vertex v.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.when_edge","page":"Functions","title":"NetworkDynamic.when_edge","text":"when_edge(dnet::DynamicNetwork, i, j) -> Vector{Spell}\n\nGet all activity spells for edge (i, j).\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.get_activity_range","page":"Functions","title":"NetworkDynamic.get_activity_range","text":"get_activity_range(dnet::DynamicNetwork; vertex=nothing, edge=nothing) -> Tuple\n\nGet the earliest onset and latest terminus for all spells.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.is_active","page":"Functions","title":"NetworkDynamic.is_active","text":"is_active(dnet::DynamicNetwork, at::Time; vertex=nothing, edge=nothing) -> Bool\n\nCheck if a vertex or edge is active at a given time.\n\n\n\n\n\nis_active(dnet::DynamicNetwork, onset, terminus; vertex=nothing, edge=nothing, rule=:any) -> Bool\n\nCheck if a vertex or edge is active during an interval. Rule can be :any (active at any point) or :all (active throughout).\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.active_vertices","page":"Functions","title":"NetworkDynamic.active_vertices","text":"active_vertices(dnet::DynamicNetwork, at::Time) -> Vector\n\nGet all vertices active at time at.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.active_edges","page":"Functions","title":"NetworkDynamic.active_edges","text":"active_edges(dnet::DynamicNetwork, at::Time) -> Vector{Tuple}\n\nGet all edges active at time at.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.network_extract","page":"Functions","title":"NetworkDynamic.network_extract","text":"network_extract(dnet::DynamicNetwork, at::Time) -> Network\n\nExtract a static network representing the state at time at.\n\n\n\n\n\nnetwork_extract(dnet::DynamicNetwork, onset::Time, terminus::Time; rule=:any) -> Network\n\nExtract a static network representing activity during an interval.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.network_slice","page":"Functions","title":"NetworkDynamic.network_slice","text":"network_slice(dnet::DynamicNetwork, times::AbstractVector) -> Vector{Network}\n\nExtract a sequence of static networks at specified time points.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.network_collapse","page":"Functions","title":"NetworkDynamic.network_collapse","text":"network_collapse(dnet::DynamicNetwork; rule=:any) -> Network\n\nCollapse dynamic network to static by including all vertices/edges that were ever active.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.set_vertex_attribute_active!","page":"Functions","title":"NetworkDynamic.set_vertex_attribute_active!","text":"set_vertex_attribute_active!(dnet, v, attr, value, onset, terminus)\n\nSet a time-varying vertex attribute.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.get_vertex_attribute_active","page":"Functions","title":"NetworkDynamic.get_vertex_attribute_active","text":"get_vertex_attribute_active(dnet, v, attr, at) -> value\n\nGet the value of a time-varying vertex attribute at a specific time.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.list_vertex_attributes_active","page":"Functions","title":"NetworkDynamic.list_vertex_attributes_active","text":"list_vertex_attributes_active(dnet::DynamicNetwork) -> Vector{Symbol}\n\nList all time-varying vertex attribute names.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.set_edge_attribute_active!","page":"Functions","title":"NetworkDynamic.set_edge_attribute_active!","text":"set_edge_attribute_active!(dnet, i, j, attr, value, onset, terminus)\n\nSet a time-varying edge attribute.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.get_edge_attribute_active","page":"Functions","title":"NetworkDynamic.get_edge_attribute_active","text":"get_edge_attribute_active(dnet, i, j, attr, at) -> value\n\nGet the value of a time-varying edge attribute at a specific time.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.list_edge_attributes_active","page":"Functions","title":"NetworkDynamic.list_edge_attributes_active","text":"list_edge_attributes_active(dnet::DynamicNetwork) -> Vector{Symbol}\n\nList all time-varying edge attribute names.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.get_observation_period","page":"Functions","title":"NetworkDynamic.get_observation_period","text":"get_observation_period(dnet::DynamicNetwork) -> Tuple\n\nGet the observation period for the network.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.set_observation_period!","page":"Functions","title":"NetworkDynamic.set_observation_period!","text":"set_observation_period!(dnet::DynamicNetwork, start, stop)\n\nSet the observation period for the network.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.get_timing_info","page":"Functions","title":"NetworkDynamic.get_timing_info","text":"get_timing_info(dnet::DynamicNetwork) -> NamedTuple\n\nGet summary timing information about the dynamic network.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.as_dynamic_network","page":"Functions","title":"NetworkDynamic.as_dynamic_network","text":"as_dynamic_network(net::Network; onset, terminus) -> DynamicNetwork\n\nConvert a static network to a dynamic network with all elements active during the specified period.\n\n\n\n\n\n","category":"function"},{"location":"api/functions.html#NetworkDynamic.reconcile_activity!","page":"Functions","title":"NetworkDynamic.reconcile_activity!","text":"reconcile_activity!(dnet::DynamicNetwork)\n\nEnsure edge activity is consistent with vertex activity. Edges are only active when both endpoints are active.\n\n\n\n\n\n","category":"function"}]
}
